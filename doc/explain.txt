


## HOW RENDERABLES WORK

Renderable.id:
1) It becomes the name of generated geojson file with all the features obtained via renderable's get_features. 
2) It also becomes the name of a tile layer.
3) It is used to produce style layers' ids on frontend in build_layers (style layer's resulting id is `${rnd_id} ${style_layer_type}`
4) style layer produced from renderable on frontend also needs r.id as the name of 'source-layer'

get_features is called in generate_tiles, resulting features go to renderable's dedicated geojson file, and then to dedicated tile layer.
Get features do totally arbitrary stuff, they can utilize city's handmade data, they can spun some "derived" features like title point for Polygons.

style_layers are mostly for frontend but their "minzoom" and "maxzoom" is applied also for tiling.

When writing renderables, #1 caveat is the possiblity of introducing build-only imports that will be downloaded by end website user. This is soluble by "top level imports" for build only. However, it's not really a valid solution because I need to remember to use such conditional TLI, and anyway build-only import can sneak through some deeply nested modules, which is basically uncontrollable. This really stinks but the extent of the problem is difficult to measure so far, and I'm waiting for more evidence. For now, the proper tool for conditional imports is a util function load_build_only_modules.

Read about renderables (including their motivation) also in  doc/hot_to_build_a_new_city.txt






## HOW TITLES POINTS ARE (CAN BE) MADE

In tile_layers_meta, add item by calling get_titles_points_tiling_settings(...),
it contains feature filter and feature transform that will be applied in generate_tiles,
matching geojson features from "main_geojson" to titles from handmade data,
and making a Point features for every match.
This will however make Point only for features that happen to be in main_geojson but some titled features will be elsewhere,
e.g. features made from renderables won't get points automatically (unless renderable.get_features gets them from main_geojson).
Do Renderable's get_features can take care of that, generating title points for polygons
(like it's done for dead buildings and unesco areas).
Basically features from renderables could be merged into main_geojson,
and this will result in having Points generated for them automatically,
but I hesitate to do that because these automatically generated Points are now in 1 big tile layer,
and this means that some work is necessary to filter them in order to get different rendering for different features.
So for now I keep this scattered system of points generation. If it gets too messy, might need to change to something more uniform.







Why I decide against rendering text along linestrings (with curves, like for rivers)
	Because it's behaving wildly,
	Disappearing at various zoom levels, and it's impossible to control
	This is not the case when symbol (text) is drawn for a point.
	Behaviour of linestring is perhaps due to insufficient space,
		and this space is perhaps defined per-tile,
		and so the space is limited not by the whole linestring
			but by its portion in a certain tile.
			Very annoying





Features come from:
	OSM
	/static_data:
		bulk,
		custom_features,
	city_assets.renderables
		including dead_buildings

Tile layers come from
	city_assets.tile_layers_meta
	"general_tile_layers_meta":
		city bulk
		boring bldgs
	city_assets.renderables
		including dead_buildings


Style layers come from
	zoom_order -> drawing_layers (+ "selectable" variants made at runtime)
	"simple" layers defined in style.mjss
	city_assets.renderables	